while (1)
{
	parse_command();  //asteapta sa scirem ceva la tastatura si dupa ce dam enter se executa

	if((pid == fork()) == 0)
	{
		/* fiu */
	}
	else 
	{
		/*tata*/
	}
}

/*tata*/
-asteapta executarea fiului si a procesului de retur al acestuia. Face asta prin
int wait( int *stare) //in stare se pune codul de retur al procesului fiu
-1 in caz de eroare ECHLD
>0 pid proces zombie (a ajuns in stare zombie, s-a terminat)
wait comparabil cu ingroparea. procesu de cand e in rulare pana ajunge in wait e precum mortu e catafalc \
care asteapta sa fie bagat in pamant(wait)


despre stare
------------
int *stare;
wait(stare);
---------------->greseala grava (pointerul neintializat) DUCE LA DEPUNCTARE!!! 50 de sutimi din 200

int *stare;
stare = (int *) malloc(sizeof(int));
wait(stare);
------------------> acum e initializat DAR mallocul consuma resurse, nu ai facut free =>depunctare mai mica

int stare;
wait(&stare);
----------------->corect

wait(NULL);





#define MAX(I, J); (I)<(J) ? (J):(I)
deci daca vom avea:
MAX(a+2, b+c) // va insemna a+2<b+c? b+c:a+2;


macro-uri
---------

WIFEXITED(stare) 
-returneza true sa false
-spune daca procesul s-a terminat in 

WEXITSTATUS(stare)


if(WIFEXITED(stare))
	rc = WEXITSTATUS(stare);


WIFSIGNALED(stare)
-daca procesul s-a terminat dupa primirea unui semnal

WTERMSIG(stare)
-ce semnal a fost.